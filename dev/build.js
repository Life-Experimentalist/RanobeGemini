/**
 * Unified Build System for Ranobe Gemini
 * Handles domain updates, registry generation, building, and packaging.
 *
 * Usage:
 *   node dev/build.js [options]
 *
 * Options:
 *   --firefox      Build for Firefox
 *   --chromium     Build for Chromium
 *   --all          Build for all platforms (default)
 *   --package      Package the build into a ZIP file
 *   --source       Package the source code
 *   --update       Update manifest domains from handlers
 *   --clean        Clean dist and releases folders
 */

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

// Configuration
const ROOT_DIR = path.resolve(__dirname, "..");
const SRC_DIR = path.join(ROOT_DIR, "src");
const DIST_DIR = path.join(ROOT_DIR, "dist");
const RELEASES_DIR = path.join(ROOT_DIR, "releases");
const HANDLERS_DIR = path.join(SRC_DIR, "utils", "website-handlers");

const ASSETS_TO_COPY = [
	"icons",
	"popup",
	"background",
	"content",
	"config",
	"utils",
	"library",
	"lib",
];

// Helper: Copy directory recursively
function copyDir(src, dest) {
	if (!fs.existsSync(dest)) {
		fs.mkdirSync(dest, { recursive: true });
	}
	const entries = fs.readdirSync(src, { withFileTypes: true });
	for (const entry of entries) {
		const srcPath = path.join(src, entry.name);
		const destPath = path.join(dest, entry.name);
		if (entry.isDirectory()) {
			copyDir(srcPath, destPath);
		} else {
			fs.copyFileSync(srcPath, destPath);
		}
	}
}

// Task: Generate Handler Registry
function generateHandlerRegistry() {
	console.log("ðŸ“‚ Generating handler registry...");
	try {
		const handlerFiles = fs
			.readdirSync(HANDLERS_DIR)
			.filter(
				(file) =>
					file.endsWith("-handler.js") && file !== "base-handler.js"
			)
			.sort();

		const registryPath = path.join(HANDLERS_DIR, "handler-registry.js");
		const registryContent = `// AUTO-GENERATED LIST OF WEBSITE HANDLER MODULE PATHS
// Generated by dev/build.js
export const HANDLER_MODULES = [
${handlerFiles.map((f) => `	"${f}",`).join("\n")}
];
`;

		fs.writeFileSync(registryPath, registryContent, "utf8");
		console.log(
			`âœ… Handler registry updated: ${handlerFiles.length} handler(s) registered.`
		);
	} catch (error) {
		console.error("âŒ Failed to generate handler registry:", error.message);
	}
}

// Task: Update Domains
function updateDomains() {
	console.log("ðŸ” Updating manifest domains...");
	try {
		// We run the script directly to ensure it uses its own logic
		execSync(
			`node "${path.join(__dirname, "generate-manifest-domains.js")}"`,
			{ stdio: "inherit" }
		);
		console.log("âœ… Domains updated successfully.");
	} catch (error) {
		console.error("âŒ Failed to update domains:", error.message);
	}
}

// Task: Clean
function clean() {
	console.log("ðŸ§¹ Cleaning build folders...");
	if (fs.existsSync(DIST_DIR)) {
		fs.rmSync(DIST_DIR, { recursive: true, force: true });
		console.log("âœ… Cleaned dist/");
	}
}

// Task: Build for Platform
function build(platform) {
	console.log(`\nðŸ”¨ Building for ${platform}...`);
	const platformDist = path.join(DIST_DIR, `dist-${platform}`);
	const manifestFile =
		platform === "firefox"
			? "manifest-firefox.json"
			: "manifest-chromium.json";
	const manifestPath = path.join(SRC_DIR, manifestFile);

	if (!fs.existsSync(platformDist)) {
		fs.mkdirSync(platformDist, { recursive: true });
	}

	// Load and update manifest
	const packageJson = JSON.parse(
		fs.readFileSync(path.join(ROOT_DIR, "package.json"), "utf8")
	);
	const manifest = JSON.parse(fs.readFileSync(manifestPath, "utf8"));
	manifest.version = packageJson.version;

	fs.writeFileSync(
		path.join(platformDist, "manifest.json"),
		JSON.stringify(manifest, null, "\t")
	);
	console.log("âœ… Generated manifest.json");

	// Copy assets
	ASSETS_TO_COPY.forEach((item) => {
		const srcPath = path.join(SRC_DIR, item);
		const destPath = path.join(platformDist, item);
		if (fs.existsSync(srcPath)) {
			if (fs.lstatSync(srcPath).isDirectory()) {
				copyDir(srcPath, destPath);
				console.log(`âœ… Copied ${item}/`);
			} else {
				fs.copyFileSync(srcPath, destPath);
				console.log(`âœ… Copied ${item}`);
			}
		}
	});

	console.log(`âœ¨ ${platform} build complete.`);
	return platformDist;
}

// Task: Package
async function packagePlatform(platform, version) {
	console.log(`\nðŸ“¦ Packaging ${platform} (v${version})...`);
	try {
		const scriptPath = path.join(__dirname, `package-${platform}.js`);
		execSync(`node "${scriptPath}" --version "${version}"`, {
			stdio: "inherit",
		});
		console.log(`âœ… ${platform} packaged successfully.`);
	} catch (error) {
		console.error(`âŒ Failed to package ${platform}:`, error.message);
	}
}

// Task: Sync source manifest files with package.json version
function syncSourceManifests(version) {
	try {
		console.log(`ðŸ” Syncing source manifests to v${version}...`);
		const firefoxPath = path.join(SRC_DIR, "manifest-firefox.json");
		const chromiumPath = path.join(SRC_DIR, "manifest-chromium.json");

		if (fs.existsSync(firefoxPath)) {
			const m = JSON.parse(fs.readFileSync(firefoxPath, "utf8"));
			m.version = version;
			fs.writeFileSync(firefoxPath, JSON.stringify(m, null, "\t"), "utf8");
			console.log("âœ… Updated src/manifest-firefox.json");
		}

		if (fs.existsSync(chromiumPath)) {
			const m = JSON.parse(fs.readFileSync(chromiumPath, "utf8"));
			m.version = version;
			fs.writeFileSync(chromiumPath, JSON.stringify(m, null, "\t"), "utf8");
			console.log("âœ… Updated src/manifest-chromium.json");
		}
	} catch (err) {
		console.error("âŒ Failed to sync source manifests:", err.message);
	}
}

// Main Execution
async function main() {
	const args = process.argv.slice(2);
	const options = {
		firefox: args.includes("--firefox"),
		chromium: args.includes("--chromium"),
		all:
			args.includes("--all") ||
			args.length === 0 ||
			(!args.includes("--firefox") && !args.includes("--chromium")),
		package: args.includes("--package"),
		source: args.includes("--source"),
		update: args.includes("--update"),
		clean: args.includes("--clean"),
	};

	if (options.clean) clean();

	// Always generate registry, but only update domains if explicitly requested or during packaging
	generateHandlerRegistry();
	if (options.update || options.package) updateDomains();

	const platforms = [];
	if (options.all || options.firefox) platforms.push("firefox");
	if (options.all || options.chromium) platforms.push("chromium");

	const packageJson = JSON.parse(
		fs.readFileSync(path.join(ROOT_DIR, "package.json"), "utf8"),
	);

	for (const platform of platforms) {
		build(platform);
		if (options.package) {
			// Make sure source manifests reflect the package.json version so they don't need manual edits
			syncSourceManifests(packageJson.version);
			await packagePlatform(platform, packageJson.version);
		}
	}

	if (options.source) {
		console.log("\nðŸ“¦ Packaging source code...");
		try {
			execSync(`node "${path.join(__dirname, "package-source.js")}"`, {
				stdio: "inherit",
			});
			console.log("âœ… Source code packaged successfully.");
		} catch (error) {
			console.error("âŒ Failed to package source:", error.message);
		}
	}

	console.log("\nðŸ Build process finished.");
}

main().catch((err) => {
	console.error("\nðŸ’¥ Fatal error:", err);
	process.exit(1);
});
